# 参考

[tasks-microtasks-queues-and-schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

# 实战

1. 翻译上文


每个“线程”都有自己的事件循环，因此每个web worker都有自己的事件循环，因此它可以独立执行，而同一原点上的所有窗口都共享一个事件循环，因为它们可以同步通信。一个事件循环有多个任务源，这些任务源保证了该源中的执行顺序, 浏览器可以在每次循环时从哪个源中选择一个任务

计划了任务，以便浏览器可以从其内部进入JavaScript / DOM领域，并确保这些操作顺序发生。 在任务之间，浏览器可以呈现更新。 从鼠标单击到事件回调，需要调度任务，解析HTML也是如此，在上面的示例中是setTimeout。

setTimeout等待给定的延迟，然后为它的回调调度一个新任务。这就是为什么setTimeout记录在脚本script end，因为记录script end是第一个任务的一部分，而setTimeout记录在一个单独的任务中。好了，我们快结束了，但我需要你在下一段时间保持坚强

微任务通常是针对当前正在执行的脚本之后应该立即发生的事情进行调度的，比如对一批操作进行响应，或者进行异步处理，而不需要承担整个新任务的代价。只要在执行过程中没有其他JavaScript，并且在每个任务结束时，就会在回调之后处理微任务队列。在微任务期间排队的任何其他微任务都被添加到队列的末尾并被处理。微任务包括突变观察者回调，与上面的示例一样，承诺回调。

一旦某个承诺确定了，或者已经确定了，它就会为它的反动回调队列一个微任务。这确保承诺回调是异步的，即使承诺已经解决。这样调用。然后(不，不)违反一个已确定的承诺，立即排队的微任务。这就是为什么在脚本结束后记录承诺1和承诺2，因为当前运行的脚本必须在处理微任务之前完成。在setTimeout之前记录承诺1和承诺2，因为微任务总是在下一个任务之前发生。


浏览器对于此的区别

有的浏览器会把`promise`作为task处理，但是目前更加一致的是把promise作为微任务


如何判断使用任务还是微任务

测试是唯一的途径。查看标准

手动出发事件（。click）和交互的触发是不一样的
在以前，这意味着微任务在侦听器回调之间运行，但是.click()会导致事件同步分派，因此调用.click()的脚本仍然在回调之间的堆栈中。上述规则确保微任务不会中断正在执行的JavaScript。这意味着我们不会在侦听器回调之间处理微任务队列，它们是在两个侦听器之后处理的。

总结：
    1. 任务按顺序执行，浏览器可以在它们之间呈现
    2. 微任务按顺序执行，并在以下两个情况下执行：
       1. 每次回调之后，只要没有其他JavaScript在执行中
       2. 在每个任务结束的时候